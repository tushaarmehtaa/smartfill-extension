// background.js

async function getHolisticFills(fields, profile, apiKey, pageContext, sendResponse) {
  // Use the stable IDs generated by content.js (el.id || `field_${index}`)
  const simplifiedFields = fields.map(field => ({
    id: field.id, // This is the crucial fix
    label: field.label,
    name: field.name,
    type: field.type,
    placeholder: field.placeholder,
    options: field.options
  }));

  // Smart field mapping function
  function getSmartFieldValue(field, profile) {
    const label = field.label.toLowerCase();
    const type = field.type.toLowerCase();
    
    // Extract first and last names
    const nameParts = (profile.name || '').split(' ');
    const firstName = nameParts[0] || '';
    const lastName = nameParts.slice(1).join(' ') || '';
    
    // Name fields
    if (label.includes('first name') || (label.includes('name') && !label.includes('last') && !label.includes('company'))) {
      return firstName;
    }
    if (label.includes('last name') || label.includes('surname') || label.includes('family name')) {
      return lastName;
    }
    
    // Contact fields
    if (label.includes('email') || type === 'email') {
      return profile.email || '';
    }
    if (label.includes('phone') || label.includes('mobile') || type === 'tel') {
      return profile.phone || '';
    }
    
    // Social/Professional URLs
    if (label.includes('linkedin')) {
      return profile.linkedin || '';
    }
    if (label.includes('github')) {
      return profile.github || '';
    }
    if (label.includes('portfolio') || label.includes('website')) {
      return profile.portfolio || '';
    }
    
    // Location fields
    if (label.includes('location') || label.includes('city') || label.includes('address')) {
      return profile.city || profile.street || '';
    }
    if (label.includes('state') || label.includes('province')) {
      return profile.state || '';
    }
    if (label.includes('zip') || label.includes('postal')) {
      return profile.zip || '';
    }
    if (label.includes('country')) {
      return profile.country || '';
    }
    
    // Professional fields
    if (label.includes('company') || label.includes('employer') || label.includes('organization')) {
      return profile.company || '';
    }
    if (label.includes('profession') || label.includes('job title') || label.includes('position') || label.includes('role')) {
      return profile.profession || '';
    }
    
    // Salary fields
    if (label.includes('salary') || label.includes('compensation') || label.includes('pay')) {
      return 'Negotiable';
    }
    
    // Open-ended fields that need AI
    if (label.includes('about') || label.includes('summary') || label.includes('bio') || 
        label.includes('experience') || label.includes('background') || 
        label.includes('why') || label.includes('tell us') || label.includes('describe')) {
      return 'AI_NEEDED';
    }
    
    return ''; // Leave empty if unsure
  }
  
  // First pass: handle simple mappings
  const values = {};
  const aiNeededFields = [];
  
  simplifiedFields.forEach(field => {
    const value = getSmartFieldValue(field, profile);
    if (value === 'AI_NEEDED') {
      aiNeededFields.push(field);
    } else {
      values[field.id] = value;
    }
  });
  
  // If no AI-needed fields, return immediately
  if (aiNeededFields.length === 0) {
    sendResponse({ values });
    return;
  }
  
  // For AI-needed fields, create a focused prompt
  const aiPrompt = `You are helping fill out a form. Here's the user's profile:

${JSON.stringify(profile, null, 2)}

Page context: ${pageContext.substring(0, 1500)}

I need you to write thoughtful responses for these open-ended questions:

${aiNeededFields.map((field, i) => `${i+1}. Field: "${field.label}" (ID: ${field.id})
   Question: ${field.label}
   Write a 2-3 sentence professional response based on the user's profile.`).join('\n\n')}

Return ONLY a JSON object with field IDs and responses:
{"field_id": "thoughtful response here"}`;

  // Only call AI for open-ended questions
  try {
    const apiResponse = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 1024,
        messages: [{ role: 'user', content: aiPrompt }]
      })
    });

    if (!apiResponse.ok) {
      const errorBody = await apiResponse.json();
      throw new Error(`Claude API Error: ${errorBody.error.message}`);
    }

    const result = await apiResponse.json();
    let jsonString = result.content[0].text;

    // The AI sometimes wraps the JSON in markdown or includes extra text. Let's robustly extract it.
    const jsonMatch = jsonString.match(/\`\`\`(?:json)?\n?([\s\S]*?)\n?\`\`\`/) || jsonString.match(/\{[\s\S]*\}/);
    if (jsonMatch && jsonMatch[1]) {
      jsonString = jsonMatch[1];
    } else if (jsonMatch && jsonMatch[0]) {
      jsonString = jsonMatch[0];
    }
    
    // Clean up any remaining markdown or extra text
    jsonString = jsonString.trim();

    // Now, parse the cleaned string
    const aiValues = JSON.parse(jsonString);
    
    // Merge AI responses with pre-filled values
    const finalValues = { ...values, ...aiValues };
    sendResponse({ values: finalValues });
  } catch (error) {
    console.error('Error calling Claude API:', error);
    const errorMessage = error.message.includes('JSON') 
      ? 'The AI returned an invalid response. Please try again.' 
      : error.message;
    sendResponse({ error: errorMessage });
  }
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'get_ai_fills') {
    getHolisticFills(request.fields, request.profile, request.apiKey, request.pageContext, sendResponse);
    return true; // Keep the message channel open for the async response
  }
});
